# generated by patch-package 6.4.14
#
# declared package:
#   vitest: 0.25.2
#
diff --git a/node_modules/vitest/dist/chunk-runtime-chain.a0b441dc.js b/node_modules/vitest/dist/chunk-runtime-chain.a0b441dc.js
index 4323980..27a9fe3 100644
--- a/node_modules/vitest/dist/chunk-runtime-chain.a0b441dc.js
+++ b/node_modules/vitest/dist/chunk-runtime-chain.a0b441dc.js
@@ -1,3 +1,5 @@
+const debugSnaps = false;
+
 import util$1 from 'util';
 import { i as isObject, b as getCallLastIndex, s as slash, g as getWorkerState, c as getNames, d as assertTypes, e as getFullName, n as noop, f as isRunningInTest, h as isRunningInBenchmark } from './chunk-typecheck-constants.4891f22f.js';
 import * as chai$2 from 'chai';
@@ -502,10 +504,18 @@ const removeExtraLineBreaks = (string) => string.length > 2 && string.startsWith
 const escapeRegex = true;
 const printFunctionName = false;
 function serialize(val, indent = 2, formatOverrides = {}) {
+
+  debugSnaps && console.dir({
+    f: "serialize",
+    val,
+    plugins: getSerializers(),
+  })
+  
   return normalizeNewlines(
     format_1(val, {
       escapeRegex,
       indent,
+      // expect.addSnapshotSerializer
       plugins: getSerializers(),
       printFunctionName,
       ...formatOverrides
@@ -547,13 +557,16 @@ ${snapshots.join("\n\n")}
   ));
 }
 function prepareExpected(expected) {
+  // dont prepare
+  //return expected
   function findStartIndent() {
     var _a, _b;
     const matchObject = /^( +)}\s+$/m.exec(expected || "");
     const objectIndent = (_a = matchObject == null ? void 0 : matchObject[1]) == null ? void 0 : _a.length;
     if (objectIndent)
       return objectIndent;
-    const matchText = /^\n( +)"/.exec(expected || "");
+    //const matchText = /^\n( +)"/.exec(expected || "");
+    const matchText = /^\n( +)\S/.exec(expected || "");
     return ((_b = matchText == null ? void 0 : matchText[1]) == null ? void 0 : _b.length) || 0;
   }
   const startIndent = findStartIndent();
@@ -607,6 +620,12 @@ async function saveInlineSnapshots(snapshots) {
     const code = await promises.readFile(file, "utf8");
     const s = new MagicString(code);
     for (const snap of snaps) {
+
+      debugSnaps && console.dir({
+        f: "saveInlineSnapshots",
+        snap,
+      })
+
       const index = posToNumber(code, snap);
       replaceInlineSnap(code, s, index, snap.snapshot);
     }
@@ -629,13 +648,48 @@ function replaceObjectSnap(code, s, index, newSnap) {
   return true;
 }
 function prepareSnapString(snap, source, index) {
+
   const lineIndex = numberToPos(source, index).line;
   const line = source.split(lineSplitRE)[lineIndex - 1];
   const indent = line.match(/^\s*/)[0] || "";
   const indentNext = indent.includes("	") ? `${indent}	` : `${indent}  `;
-  const lines = snap.trim().replace(/\\/g, "\\\\").split(/\n/g);
+  //const lines = snap.trim().replace(/\\/g, "\\\\").split(/\n/g);
+  // dont trim
+  //const lines = snap.replace(/\\/g, "\\\\").split(/\n/g);
+  // trim right
+  const lines = snap.replace(/\s*$/s, "").replace(/\\/g, "\\\\").split(/\n/g);
+  // left trim empty lines, but keep indent of first line
+  for (const line of lines) {
+    if (/^\s*$/.test(line)) {
+      lines.shift();
+    }
+    else {
+      break;
+    }
+  }
   const isOneline = lines.length <= 1;
   const quote = isOneline ? "'" : "`";
+
+  debugSnaps && console.dir({
+    f: "prepareSnapString",
+    snap,
+    line,
+    indent,
+    indentNext,
+    isOneline,
+    lines,
+    //source, index // test file source
+  })
+
+// add indentNext
+//${lines.map((i) => i ? indentNext + i : "").join("\n").replace(/`/g, "\\`").replace(/\${/g, "\\${")}
+// dont add indentNext
+//${lines.join("\n").replace(/`/g, "\\`").replace(/\${/g, "\\${")}
+
+// dont wrap
+//return `${quote}${snap.replace(/`/g, "\\`").replace(/\${/g, "\\${")}${quote}`
+
+
   if (isOneline)
     return `'${lines.join("\n").replace(/'/g, "\\'")}'`;
   else
@@ -643,8 +697,15 @@ function prepareSnapString(snap, source, index) {
 ${lines.map((i) => i ? indentNext + i : "").join("\n").replace(/`/g, "\\`").replace(/\${/g, "\\${")}
 ${indent}${quote}`;
 }
+
 const startRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\S\s]*\*\/\s*|\/\/.*\s+)*\s*[\w_$]*(['"`\)])/m;
 function replaceInlineSnap(code, s, index, newSnap) {
+
+  debugSnaps && console.dir({
+    f: "replaceInlineSnap",
+    newSnap,
+  })
+
   const startMatch = startRegex.exec(code.slice(index));
   if (!startMatch)
     return replaceObjectSnap(code, s, index, newSnap);
@@ -742,6 +803,12 @@ ${JSON.stringify(stacks)}`
         );
       }
       stack.column--;
+
+      debugSnaps && console.dir({
+        f: "SnapshotState._addSnapshot",
+        receivedSerialized,
+      })
+
       this._inlineSnapshots.push({
         snapshot: receivedSerialized,
         ...stack
@@ -770,8 +837,15 @@ ${JSON.stringify(stacks)}`
     if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {
       if (hasExternalSnapshots)
         await saveSnapshotFile(this._snapshotData, this.snapshotPath);
-      if (hasInlineSnapshots)
+      if (hasInlineSnapshots) {
+
+        debugSnaps && console.dir({
+          f: "SnapshotState.save",
+          _inlineSnapshots: this._inlineSnapshots,
+        })
+
         await saveInlineSnapshots(this._inlineSnapshots);
+      }
       status.saved = true;
     } else if (!hasExternalSnapshots && fs.existsSync(this.snapshotPath)) {
       if (this._updateSnapshot === "all")
@@ -807,7 +881,17 @@ ${JSON.stringify(stacks)}`
       key = testNameToKey(testName, count);
     if (!(isInline && this._snapshotData[key] !== void 0))
       this._uncheckedKeys.delete(key);
-    const receivedSerialized = addExtraLineBreaks(serialize(received, void 0, this._snapshotFormat));
+
+    debugSnaps && console.dir({
+      f: "sstate.match",
+      received,
+    })
+
+    //const receivedSerialized = addExtraLineBreaks(serialize(received, void 0, this._snapshotFormat));
+    // dont wrap with empty lines
+    // already done in prepareSnapString
+    const receivedSerialized = serialize(received, void 0, this._snapshotFormat);
+
     const expected = isInline ? inlineSnapshot : this._snapshotData[key];
     const expectedTrimmed = prepareExpected(expected);
     const pass = expectedTrimmed === prepareExpected(receivedSerialized);
@@ -931,6 +1015,13 @@ class SnapshotClient {
       errorMessage
     } = options;
     let { received } = options;
+
+    debugSnaps && console.dir({
+      f: "SnapshotClient.assert",
+      received,
+      inlineSnapshot,
+    })
+
     if (!test)
       throw new Error("Snapshot cannot be used outside of test");
     if (typeof properties === "object") {
@@ -960,13 +1051,19 @@ class SnapshotClient {
       inlineSnapshot
     });
     if (!pass) {
+      debugSnaps && console.log(`SnapshotClient.assert: pass == false`)
       try {
         expect(actual.trim()).equals(expected ? expected.trim() : "");
+        // dont trim
+        //expect(actual).equals(expected ? expected : "");
       } catch (error2) {
         error2.message = errorMessage || `Snapshot \`${key || "unknown"}\` mismatched`;
         throw error2;
       }
     }
+    else {
+      debugSnaps && console.log(`SnapshotClient.assert: pass == true`)
+    }
   }
   async saveCurrent() {
     if (!this.snapshotState)
@@ -1040,8 +1137,16 @@ const SnapshotPlugin = (chai, utils) => {
         inlineSnapshot = properties;
         properties = void 0;
       }
+      /*
       if (inlineSnapshot)
         inlineSnapshot = stripSnapshotIndentation(inlineSnapshot);
+      */
+      debugSnaps && console.dir({
+        f: "toMatchInlineSnapshot",
+        expected,
+        inlineSnapshot,
+      })
+
       const errorMessage = utils.flag(this, "message");
       getSnapshotClient().assert({
         received: expected,
